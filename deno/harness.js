// Generated by CoffeeScript 2.5.1
var continuations, idx, loadModule, module, processRpc, reactiveIds, reactives, registerContinuation, registerReactive, wrapValue;

module = {};

import {
  isReactive,
  toRaw
} from 'https://esm.sh/@vue/reactivity@3.0.4';

loadModule = async function(filename) {
  var e;
  try {
    return module = (await import(filename));
  } catch (error) {
    // console.log 'loaded module', module
    e = error;
    console.error('module load error', filename);
    console.error(e);
    throw e;
  }
};

wrapValue = function(result) {
  return {
    raw: result
  };
};

idx = 0;

continuations = {};

registerContinuation = function(fn) {
  var id;
  id = idx += 1;
  continuations[id] = fn;
  return {
    continue: id
  };
};

reactiveIds = new WeakMap();

reactives = {};

registerReactive = function(rx) {
  var id;
  id = reactiveIds.get(rx) || (id = idx += 1, reactiveIds.set(rx, id), id);
  reactives[id] = rx;
  return {
    reactive: id,
    raw: toRaw(rx)
  };
};

processRpc = function(callId, result) {
  result = (function() {
    switch (typeof result) {
      case 'function':
        return registerContinuation(result);
      case 'object':
        if (isReactive(result)) {
          return registerReactive(result);
        } else {
          return wrapValue(result);
        }
        break;
      default:
        return wrapValue(result);
    }
  })();
  return postMessage(['resolve', callId, result]);
};

self.onmessage = async function({
    data: [event, ...args]
  }) {
  var callId, context, continuationId, e, exp, k, raw, rxId, uri, v;
  try {
    if (event === 'loadModule') {
      [callId, uri] = args;
      try {
        await loadModule(uri);
        return postMessage(['resolve', callId]);
      } catch (error) {
        e = error;
        return postMessage(['reject', callId, e.message]);
      }
    } else if (event === 'callExport') {
      [callId, exp, args, context] = args;
      try {
        if (typeof module[exp] === 'function') {
          if (!Array.isArray(args)) {
            args = [args];
          }
          context.requireAdmin = function() {
            if (!this.identity.admin) {
              throw new Error('unauthorized');
            }
          };
          return processRpc(callId, (await module[exp].apply(context, args)));
        } else {
          // if typeof args is 'object'
          // 	module[exp][k] = v for k, v of args
          return postMessage(['resolve', callId, toRaw(module[exp])]);
        }
      } catch (error) {
        e = error;
        console.error(e);
        return postMessage([
          'reject',
          callId,
          {
            message: e.message
          }
        ]);
      }
    } else if (event === 'continuation') {
      [callId, continuationId, args, context] = args;
      return processRpc(callId, (await continuations[continuationId].apply(context, args)));
    } else if (event === 'reactive') {
      [callId, rxId, raw] = args;
      for (k in raw) {
        v = raw[k];
        reactives[rxId][k] = v;
      }
      return postMessage([
        'resolve',
        callId,
        {
          done: true
        }
      ]);
    }
  } catch (error) {
    e = error;
    console.error(e);
    throw e;
  }
};
