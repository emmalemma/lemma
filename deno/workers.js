// Generated by CoffeeScript 2.5.1
var SocketProxy, delay, harnesses, hostApi, hostSocket, hostWorker, loadModule, loadWorker, modules, onWorkerError, onWorkerMessage, requests, sockets, watchTarget;

harnesses = {};

requests = {};

import {
  reactive
} from 'https://esm.sh/@vue/reactivity@3.0.4';

import {
  Api
} from './api.js';

delay = function(ms) {
  return new Promise(function(res) {
    return setTimeout(res, ms);
  });
};

hostWorker = function(target) {
  return Api.router.post(`/${target}/:exportName`, async function(context) {
    var e, request, response, result, rid;
    ({request, response} = context);
    rid = request.serverRequest.conn.rid;
    // console.log context.params, harnesses
    harnesses[target].postMessage([
      'callExport',
      rid,
      context.params.exportName,
      (await request.body().value),
      {
        identity: context.identity,
        headers: context.request.headers
      }
    ]);
    try {
      result = (await new Promise(function(resolve, reject) {
        return requests[rid] = {resolve, reject, context};
      }));
    } catch (error1) {
      e = error1;
      response.status = 500;
      result = e;
    }
    return response.json = result;
  });
};

SocketProxy = class SocketProxy {
  constructor(setup1) {
    this.setup = setup1;
  }

  connect(socket) {
    var handlers;
    handlers = {};
    (async function() {
      var data, message, ref, results;
      results = [];
      for await (message of socket) {
        if (typeof message !== 'string') {
          console.error({
            error: message
          });
          continue;
        }
        data = JSON.parse(message);
        results.push((ref = handlers[data.target]) != null ? ref.apply(null, data.args) : void 0);
      }
      return results;
    })();
    return this.setup(new Proxy({}, {
      get: function(_, target) {
        return function(...args) {
          return socket.send(JSON.stringify({target, args}));
        };
      },
      set: function(target, prop, value) {
        return handlers[prop] = value;
      }
    }));
  }

};

export var realtime = function(setup) {
  return new SocketProxy(setup);
};

sockets = {};

hostSocket = function(target, exportName) {
  var name;
  return sockets[name = `${target}:${exportName}`] != null ? sockets[name] : sockets[name] = Api.router.get(`/${target}/${exportName}`, async function(context) {
    var proxy;
    if (context.isUpgradable) {
      proxy = modules[target][exportName].apply(context, (await context.request.body().value));
      return proxy.connect((await context.upgrade()));
    }
  });
};

modules = {};

hostApi = function(target) {
  return Api.router.post(`/${target}/:exportName`, async function(context) {
    var e, request, response, result, rid;
    ({request, response} = context);
    rid = request.serverRequest.conn.rid;
    try {
      if (context.params.exportName.match(/^_/)) {
        throw new Error('invalid export');
      }
      result = (await modules[target][context.params.exportName].apply(context, (await request.body().value)));
      if (result instanceof SocketProxy) {
        hostSocket(target, context.params.exportName);
        return response.json = {
          socket: request.url.href.replace(/https/, 'wss')
        };
      } else {
        return response.json = {
          raw: result
        };
      }
    } catch (error1) {
      e = error1;
      response.status = 500;
      console.error('API error', target);
      console.error(e.stack);
      return response.json = {
        error: {
          stack: e.stack,
          message: e.message
        }
      };
    }
  });
};

Api.router.post("/workers/:target/continuation/:id", async function(context) {
  var e, request, response, result, rid;
  ({request, response} = context);
  rid = request.serverRequest.conn.rid;
  harnesses[context.params.target].postMessage(['continuation', rid, context.params.id, (await request.body().value), context.identity]);
  try {
    result = (await new Promise(function(resolve, reject) {
      return requests[rid] = {resolve, reject};
    }));
  } catch (error1) {
    e = error1;
    response.status = 500;
    result = e;
  }
  return response.json = result;
});

Api.router.post("/workers/:target/reactive/:id", async function(context) {
  var e, request, response, result, rid;
  ({request, response} = context);
  rid = request.serverRequest.conn.rid;
  // console.log context.params, harnesses
  harnesses[context.params.target].postMessage(['reactive', rid, context.params.id, (await request.body().value), context.identity]);
  try {
    result = (await new Promise(function(resolve, reject) {
      return requests[rid] = {resolve, reject};
    }));
  } catch (error1) {
    e = error1;
    response.status = 500;
    result = e;
  }
  return response.json = result;
});

onWorkerMessage = function({
    data: [event, callId, result]
  }) {
  // console.log [event, callId, result]
  switch (event) {
    case 'resolve':
      requests[callId].resolve(result);
      break;
    case 'reject':
      requests[callId].reject(result);
  }
  return delete requests[callId];
};

onWorkerError = function(error) {
  console.error('worker error');
  console.error(error);
  return error.preventDefault();
};

loadWorker = async function(target, uri) {
  var callId, harness, loaded, previous, state;
  previous = harnesses[target];
  harness = harnesses[target] = new Worker(new URL('harness.js', import.meta.url).href, {
    type: 'module',
    deno: true
  });
  callId = `worker-${target}`;
  harness.postMessage(['loadModule', callId, uri]);
  harness.onmessage = onWorkerMessage;
  harness.onerror = onWorkerError;
  loaded = new Promise(function(resolve, reject) {
    return requests[callId] = {resolve, reject};
  });
  if (previous) {
    previous.postMessage(['teardown', callId]);
    state = (await new Promise(function(resolve, reject) {
      return requests[callId] = {resolve, reject};
    }));
    await loaded;
    return harness.postMessage(['upgrade', state]);
  } else {
    return loaded;
  }
};

loadModule = async function(target, uri) {
  var e, module, previous;
  previous = modules[target];
  try {
    module = modules[target] = (await import(`${uri}?${Date.now()}`));
    console.log('new module loaded');
    if (previous) {
      return typeof module._upgrade === "function" ? module._upgrade(previous) : void 0;
    }
  } catch (error1) {
    e = error1;
    console.error('hot reload failed');
    return console.error(e);
  }
};

watchTarget = async function(target, path, reload) {
  var debounce, event, ref, results, uri;
  uri = `file:///${Deno.cwd()}/${path}`;
  console.log({
    watch: {target, path, uri}
  });
  reload(target, uri);
  debounce = null;
  ref = Deno.watchFs(path);
  results = [];
  for await (event of ref) {
    console.log({event});
    if (event.kind === 'modify') {
      results.push(debounce != null ? debounce : debounce = (async function() {
        await reload(target, uri);
        await delay(100);
        return debounce = null;
      })());
    } else {
      results.push(void 0);
    }
  }
  return results;
};

export var serveWorkers = async function({path, matches}) {
  var e, entry, i, len, ref, results, target, worker_file, worker_files;
  worker_files = [];
  try {
    ref = Deno.readDir(path);
    for await (entry of ref) {
      console.log('loading ', entry);
      if (entry.name.match(matches)) {
        worker_files.push(`${path}/${entry.name}`);
      }
    }
  } catch (error1) {
    e = error1;
    console.error(`Can't read apis: ${path}`);
  }
  results = [];
  for (i = 0, len = worker_files.length; i < len; i++) {
    worker_file = worker_files[i];
    console.log('loading worker', worker_file);
    target = worker_file.match(/([^\/\\]+)\.[a-z]+$/)[1];
    hostWorker(target);
    results.push(watchTarget(target, worker_file, loadWorker));
  }
  return results;
};

export var serveApis = async function({path, matches}) {
  var e, entry, i, len, ref, results, target, worker_file, worker_files;
  worker_files = [];
  try {
    ref = Deno.readDir(path);
    for await (entry of ref) {
      console.log('loading ', entry);
      if (entry.name.match(/\.js$/)) {
        worker_files.push(`${path}/${entry.name}`);
      }
    }
  } catch (error1) {
    e = error1;
    console.error(`Can't read apis: ${path}`);
  }
  results = [];
  for (i = 0, len = worker_files.length; i < len; i++) {
    worker_file = worker_files[i];
    target = worker_file.match(/([^\/\\]+)\.[a-z]+$/)[1];
    hostApi(target);
    results.push(watchTarget(target, worker_file, loadModule));
  }
  return results;
};
