// Generated by CoffeeScript 2.5.1
var SocketProxy, harnesses, hostApi, hostSocket, hostWorker, modules, onWorkerError, onWorkerMessage, requests, sockets, watchModule;

harnesses = {};

requests = {};

import {
  reactive
} from 'https://esm.sh/@vue/reactivity@3.0.4';

import {
  Api
} from './api.js';

hostWorker = function(target) {
  return Api.router.post(`/${target}/:exportName`, async function(context) {
    var e, request, response, result, rid;
    ({request, response} = context);
    rid = request.serverRequest.conn.rid;
    // console.log context.params, harnesses
    harnesses[target].postMessage([
      'callExport',
      rid,
      context.params.exportName,
      (await request.body().value),
      {
        identity: context.identity,
        headers: context.request.headers
      }
    ]);
    try {
      result = (await new Promise(function(resolve, reject) {
        return requests[rid] = {resolve, reject, context};
      }));
    } catch (error1) {
      e = error1;
      response.status = 500;
      result = e;
    }
    return response.json = result;
  });
};

SocketProxy = class SocketProxy {
  constructor(setup1) {
    this.setup = setup1;
  }

  connect(socket) {
    var handlers;
    handlers = {};
    (async function() {
      var data, message, ref, results;
      results = [];
      for await (message of socket) {
        if (typeof message !== 'string') {
          console.error({
            error: message
          });
          continue;
        }
        data = JSON.parse(message);
        results.push((ref = handlers[data.target]) != null ? ref.apply(null, data.args) : void 0);
      }
      return results;
    })();
    return this.setup(new Proxy({}, {
      get: function(_, target) {
        return function(...args) {
          return socket.send(JSON.stringify({target, args}));
        };
      },
      set: function(target, prop, value) {
        return handlers[prop] = value;
      }
    }));
  }

};

export var realtime = function(setup) {
  return new SocketProxy(setup);
};

sockets = {};

hostSocket = function(target, exportName) {
  var name;
  return sockets[name = `${target}:${exportName}`] != null ? sockets[name] : sockets[name] = Api.router.get(`/${target}/${exportName}`, async function(context) {
    var proxy;
    if (context.isUpgradable) {
      proxy = modules[target][exportName].apply(context, (await context.request.body().value));
      return proxy.connect((await context.upgrade()));
    }
  });
};

modules = {};

hostApi = function(target) {
  return Api.router.post(`/${target}/:exportName`, async function(context) {
    var e, request, response, result, rid;
    ({request, response} = context);
    rid = request.serverRequest.conn.rid;
    try {
      if (context.params.exportName.match(/^_/)) {
        throw new Error('invalid export');
      }
      result = (await modules[target][context.params.exportName].apply(context, (await request.body().value)));
      if (result instanceof SocketProxy) {
        hostSocket(target, context.params.exportName);
        return response.json = {
          socket: request.url.href.replace(/https/, 'wss')
        };
      } else {
        return response.json = {
          raw: result
        };
      }
    } catch (error1) {
      e = error1;
      response.status = 500;
      console.error('API error', target);
      console.error(e.stack);
      return response.json = {
        error: {
          stack: e.stack,
          message: e.message
        }
      };
    }
  });
};

Api.router.post("/workers/:target/continuation/:id", async function(context) {
  var e, request, response, result, rid;
  ({request, response} = context);
  rid = request.serverRequest.conn.rid;
  harnesses[context.params.target].postMessage(['continuation', rid, context.params.id, (await request.body().value), context.identity]);
  try {
    result = (await new Promise(function(resolve, reject) {
      return requests[rid] = {resolve, reject};
    }));
  } catch (error1) {
    e = error1;
    response.status = 500;
    result = e;
  }
  return response.json = result;
});

Api.router.post("/workers/:target/reactive/:id", async function(context) {
  var e, request, response, result, rid;
  ({request, response} = context);
  rid = request.serverRequest.conn.rid;
  // console.log context.params, harnesses
  harnesses[context.params.target].postMessage(['reactive', rid, context.params.id, (await request.body().value), context.identity]);
  try {
    result = (await new Promise(function(resolve, reject) {
      return requests[rid] = {resolve, reject};
    }));
  } catch (error1) {
    e = error1;
    response.status = 500;
    result = e;
  }
  return response.json = result;
});

onWorkerMessage = function({
    data: [event, callId, result]
  }) {
  // console.log [event, callId, result]
  if (event === 'resolve') {
    requests[callId].resolve(result);
  } else if (event === 'reject') {
    requests[callId].reject(result);
  }
  return delete requests[callId];
};

onWorkerError = function(error) {
  console.error('worker error');
  console.error(error);
  return error.preventDefault();
};

export var serveWorkers = async function({path, matches}) {
  var entry, harness, i, len, ref, results, target, worker_file, worker_files;
  worker_files = [];
  ref = Deno.readDir(path);
  for await (entry of ref) {
    if (entry.name.match(matches)) {
      worker_files.push(`${path}/${entry.name}`);
    }
  }
  results = [];
  for (i = 0, len = worker_files.length; i < len; i++) {
    worker_file = worker_files[i];
    console.log('loading worker', worker_file);
    target = worker_file.match(/([^\/\\]+)\.[a-z]+$/)[1];
    hostWorker(target);
    harness = harnesses[target] = new Worker(new URL('harness.js', import.meta.url).href, {
      type: 'module',
      deno: true
    });
    harness.postMessage(['loadWorker', `file:///${Deno.cwd()}/${worker_file}`]);
    harness.onmessage = onWorkerMessage;
    results.push(harness.onerror = onWorkerError);
  }
  return results;
};

watchModule = async function(target, path, uri) {
  var debounce, event, ref, results;
  console.log({
    watch: {target, path, uri}
  });
  debounce = null;
  ref = Deno.watchFs(path);
  results = [];
  for await (event of ref) {
    console.log({event});
    if (event.kind === 'modify') {
      results.push(debounce != null ? debounce : debounce = setTimeout((async function() {
        var e, module, previous;
        debounce = null;
        previous = modules[target];
        try {
          module = modules[target] = (await import(`${uri}?${Date.now()}`));
          console.log('new module loaded');
          return typeof module._upgrade === "function" ? module._upgrade(previous) : void 0;
        } catch (error1) {
          e = error1;
          console.error('hot reload failed');
          return console.error(e);
        }
      }), 100));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

export var serveApis = async function({path, matches}) {
  var e, entry, i, len, module, ref, results, target, uri, worker_file, worker_files, worker_path;
  worker_files = [];
  ref = Deno.readDir(path);
  for await (entry of ref) {
    if (entry.name.match(matches)) {
      worker_files.push(`${path}/${entry.name}`);
    }
  }
  results = [];
  for (i = 0, len = worker_files.length; i < len; i++) {
    worker_file = worker_files[i];
    target = worker_file.match(/([^\/\\]+)\.[a-z]+$/)[1];
    worker_path = `${worker_file}`;
    hostApi(target);
    uri = `file:///${Deno.cwd()}/${worker_path}`;
    try {
      // console.log {target, worker_file, worker_path, uri}
      module = modules[target] = (await import(`${uri}?${Date.now()}`));
    } catch (error1) {
      e = error1;
      console.error('api load failed');
      console.error(e);
      modules[target] = {
        error: e
      };
    }
    results.push(watchModule(target, `${worker_path}`, uri));
  }
  return results;
};
