// Generated by CoffeeScript 2.5.1
var readJson, writeJson;

import * as fs from "https://deno.land/std@0.80.0/fs/mod.ts";

readJson = async function(path) {
  return JSON.parse((await Deno.readTextFile(path)));
};

writeJson = async function(path, object) {
  return (await Deno.writeTextFile(path, JSON.stringify(object, null, 2)));
};

export var DataStore = class DataStore {
  constructor(path1, {indexes} = {}) {
    this.path = path1;
    this.indexes = indexes;
    fs.ensureDir(this.path);
    fs.ensureDir(`${this.path}/.backup`);
    this.index = {};
    this.readIndex();
  }

  async readIndex() {
    var base1, e, k, results;
    try {
      this.index = ((await readJson(`${this.path}/.index`))) || {};
    } catch (error) {
      e = error;
      console.log('Index read error', e);
    }
    results = [];
    for (k in this.indexes) {
      results.push((base1 = this.index)[k] != null ? base1[k] : base1[k] = {});
    }
    return results;
  }

  async persistIndex() {
    return (await writeJson(`${this.path}/.index`, this.index));
  }

  async readAll(path) {
    var base, entry, k, m, ref, ref1, v;
    if (path == null) {
      path = this.path;
    }
    base = {};
    ref = Deno.readDir(`${path}`);
    for await (entry of ref) {
      if (entry.isFile && (m = entry.name.match(/^(.*)\.json$/))) {
        if (m[1] === '') {
          ref1 = (await readJson(`${path}/${entry.name}`));
          for (k in ref1) {
            v = ref1[k];
            base[k] = v;
          }
        } else if (m[1][0] === '.') {
          continue;
        } else {
          base[m[1]] = (await readJson(`${path}/${entry.name}`));
        }
      } else if (entry.isDirectory && !entry.name.match(/^./)) {
        base[entry.name] = (await this.readAll(`${path}/${entry.name}`));
      }
    }
    return base;
  }

  async read(id) {
    var dirPath, e, jsonPath, stat;
    try {
      stat = (await Deno.stat(jsonPath = `${this.path}/${id}.json`));
      if (stat.isFile) {
        return (await readJson(jsonPath));
      }
    } catch (error) {
      e = error;
    }
    try {
      
      stat = (await Deno.stat(dirPath = `${this.path}/${id}`));
      if (stat.isDirectory) {
        return (await this.readAll(dirPath));
      }
    } catch (error) {
      e = error;
    }
    
    return null;
  }

  async write(id, object) {
    var base1, e, fn, index, indexed, jsonPath, key, ref, stat, value;
    try {
      stat = (await Deno.stat(jsonPath = `${this.path}/${id}.json`));
      if (stat.isFile) {
        await Deno.rename(jsonPath, `${this.path}/.backup/${id}.json`);
      }
    } catch (error) {
      e = error;
      console.log('existing json not found');
    }
    await writeJson(jsonPath, object);
    indexed = false;
    ref = this.indexes;
    for (key in ref) {
      fn = ref[key];
      indexed = true;
      value = fn(object);
      if (value != null) {
        (index = (base1 = this.index)[key] != null ? base1[key] : base1[key] = {})[fn(object)] = id;
      }
    }
    if (indexed) {
      return this.persistIndex();
    }
  }

};

// console.log 'wrote', object, 'to', jsonPath
