// Generated by CoffeeScript 2.5.1
var idStore, identities, makeToken, readToken;

import {
  jwt,
  uuid
} from './deps.js';

import {
  DataStore
} from './datastore.js';

import * as bcrypt from "https://deno.land/x/bcrypt@v0.2.4/mod.ts";

import Config from './config.js';

identities = {};

idStore = new DataStore('./data/identities', {
  indexes: {
    username: function(record) {
      return record.username;
    }
  }
});

readToken = async function(token) {
  return (await jwt.verify(token, Config.jwt.keys[0], Config.jwt.algorithm));
};

makeToken = async function(payload) {
  return (await jwt.create({
    alg: Config.jwt.algorithm,
    typ: 'jwt'
  }, payload, Config.jwt.keys[0]));
};

export var assignId = async function(context, id) {
  var iat, payload, token;
  token = (await makeToken(payload = {
    sub: id,
    iat: iat = Math.floor(Date.now() / 1000),
    exp: iat + 30 * 24 * 60 * 60
  }));
  return context.cookies.set('Identity', token, {
    domain: context.request.url.hostname,
    expires: new Date(payload.exp * 1000),
    httpOnly: true,
    overwrite: true,
    secure: true,
    sameSite: 'strict'
  });
};

export var destroyId = function(context) {
  return context.cookies.delete('Identity', {
    domain: context.request.url.hostname
  });
};

export var saveId = function(identity) {
  return idStore.write(identity.guid, identity);
};

export var authenticateUser = async function(username, password) {
  var id, identity, ref;
  id = (ref = idStore.index.username) != null ? ref[username] : void 0;
  if (!id) {
    throw new Error('no such user');
  }
  identity = (await idStore.read(id));
  if (!(await bcrypt.compare(password, identity.password))) {
    throw new Error('invalid password');
  }
  return identity;
};

export var registerUser = async function(username, password) {
  if (!(username && password)) {
    throw new Error('username and password must exist');
  }
  if (idStore.index.username[username]) {
    throw new Error('username is already registered');
  }
  if (this.identity.username && this.identity.password) {
    throw new Error('user record has a username already');
  }
  this.identity.username = username;
  this.identity.password = (await bcrypt.hash(password));
  return (await saveId(this.identity));
};

export var AuthIdentity = async function(context, next) {
  var name, payload, token;
  token = context.cookies.get('Identity');
  if (token) {
    payload = (await readToken(token));
  }
  if (!payload) {
    payload = {
      sub: uuid.v4.generate()
    };
    assignId(context, payload.sub);
  } else {
    if (payload.guid) {
      payload.sub = payload.guid;
    }
    if (!payload.iat || payload.iat < (Date.now() / 1000) - 30 * 60 * 60) {
      assignId(context, payload.sub);
    }
  }
  context.identity = identities[name = payload.sub] != null ? identities[name] : identities[name] = ((await idStore.read(payload.sub))) || {
    guid: payload.sub
  };
  context.requireAdmin = function() {
    if (!context.identity.admin) {
      throw new Error('requires admin');
    }
  };
  return next();
};
